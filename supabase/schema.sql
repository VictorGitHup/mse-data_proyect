
-- -----------------------------------------------------------------------------
-- 1. TIPOS DE DATOS PERSONALIZADOS (ENUMS)
-- -----------------------------------------------------------------------------

-- Define los roles de usuario para asegurar consistencia
create type public.user_role as enum ('USER', 'ADVERTISER');

-- Define los posibles estados de un anuncio
create type public.ad_status as enum ('active', 'inactive', 'draft', 'expired');

-- Define los posibles estados de un comentario
create type public.comment_status as enum ('pending', 'approved', 'rejected');


-- -----------------------------------------------------------------------------
-- 2. TABLAS DE LA BASE DE DATOS
-- -----------------------------------------------------------------------------

-- Almacena información pública del perfil de cada usuario.
create table public.profiles (
  id uuid not null primary key, -- Se vincula a auth.users.id
  updated_at timestamptz,
  username text unique,
  full_name text,
  avatar_url text,
  role user_role,
  contact_email text,
  contact_whatsapp text,
  contact_telegram text,
  contact_social_url text,

  constraint username_length check (char_length(username) >= 3)
);
comment on table public.profiles is 'Almacena el perfil público de los usuarios.';


-- Tabla maestra para las categorías de los anuncios.
create table public.categories (
  id int primary key generated by default as identity,
  name text not null
);
comment on table public.categories is 'Tabla maestra para las categorías de anuncios.';


-- Tabla maestra para las ubicaciones (países, regiones, etc.).
create table public.locations (
  id int primary key generated by default as identity,
  name text not null,
  type text not null, -- ej: 'country', 'region', 'subregion'
  parent_id int references public.locations(id),
  code text -- ej: 'MX', 'COL', etc.
);
comment on table public.locations is 'Ubicaciones jerárquicas (país, región, ciudad).';


-- Tabla principal para los anuncios.
create table public.ads (
  id bigint primary key generated by default as identity,
  user_id uuid references public.profiles on delete cascade not null,
  title text not null,
  description text,
  category_id int references public.categories(id) not null,
  country_id int references public.locations(id) not null,
  region_id int references public.locations(id) not null,
  subregion_id int references public.locations(id),
  image_url text,
  video_url text,
  slug text unique,
  status ad_status default 'draft',
  created_at timestamptz default now(),
  updated_at timestamptz
);
comment on table public.ads is 'Anuncios publicados por los anunciantes.';


-- Tabla para almacenar las calificaciones de los anuncios.
create table public.ratings (
  id bigint primary key generated by default as identity,
  ad_id bigint references public.ads(id) on delete cascade not null,
  user_id uuid references public.profiles on delete cascade not null,
  rating smallint not null check (rating >= 1 and rating <= 5),
  created_at timestamptz default now(),

  -- Un usuario solo puede calificar un anuncio una vez.
  unique (ad_id, user_id)
);
comment on table public.ratings is 'Calificaciones (1-5 estrellas) de los usuarios para los anuncios.';


-- Tabla para los comentarios en los anuncios.
create table public.comments (
  id bigint primary key generated by default as identity,
  ad_id bigint references public.ads(id) on delete cascade not null,
  user_id uuid references public.profiles on delete cascade not null,
  content text not null,
  status comment_status default 'pending',
  created_at timestamptz default now(),
  parent_comment_id bigint references public.comments(id) on delete cascade -- para respuestas anidadas
);
comment on table public.comments is 'Comentarios de los usuarios en los anuncios.';


-- -----------------------------------------------------------------------------
-- 3. FUNCIÓN Y TRIGGER PARA CREAR PERFILES AUTOMÁTICAMENTE
-- -----------------------------------------------------------------------------

-- Función que se ejecuta cuando un nuevo usuario se registra.
-- Inserta una fila en public.profiles utilizando los metadatos del usuario.
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public.profiles (id, full_name, username, role)
  values (
    new.id,
    new.raw_user_meta_data->>'full_name',
    new.raw_user_meta_data->>'username',
    (new.raw_user_meta_data->>'role')::user_role
  );
  return new;
end;
$$;

-- Trigger que llama a la función handle_new_user cada vez que se crea un usuario.
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();


-- -----------------------------------------------------------------------------
-- 4. CONFIGURACIÓN DEL ALMACENAMIENTO (STORAGE)
-- -----------------------------------------------------------------------------

-- Crear buckets para avatares e imágenes de anuncios.
insert into storage.buckets (id, name, public)
values
  ('avatars', 'avatars', true),
  ('ad_images', 'ad_images', true),
  ('ad_videos', 'ad_videos', true)
on conflict (id) do nothing;


-- -----------------------------------------------------------------------------
-- 5. POLÍTICAS DE SEGURIDAD A NIVEL DE FILA (RLS)
-- -----------------------------------------------------------------------------

-- Habilitar RLS en todas las tablas relevantes.
alter table public.profiles enable row level security;
alter table public.ads enable row level security;
alter table public.categories enable row level security;
alter table public.locations enable row level security;
alter table public.ratings enable row level security;
alter table public.comments enable row level security;

-- ** Políticas para la tabla PROFILES **
-- Los usuarios pueden ver todos los perfiles.
create policy "Public profiles are viewable by everyone."
  on public.profiles for select using (true);
-- Los usuarios solo pueden actualizar su propio perfil.
create policy "Users can insert and update their own profile."
  on public.profiles for update using (auth.uid() = id);

-- ** Políticas para las tablas CATEGORIES y LOCATIONS **
-- Todos pueden ver las categorías y ubicaciones.
create policy "Categories are viewable by everyone."
  on public.categories for select using (true);
create policy "Locations are viewable by everyone."
  on public.locations for select using (true);

-- ** Políticas para la tabla ADS **
-- Todos pueden ver los anuncios activos.
create policy "Active ads are viewable by everyone."
  on public.ads for select using (status = 'active');
-- Los anunciantes pueden ver sus propios anuncios, sin importar el estado.
create policy "Advertisers can view their own ads."
  on public.ads for select using (auth.uid() = user_id);
-- Los anunciantes pueden crear anuncios.
create policy "Advertisers can create ads."
  on public.ads for insert with check (
    auth.uid() = user_id and
    (select role from public.profiles where id = auth.uid()) = 'ADVERTISER'
  );
-- Los anunciantes solo pueden actualizar sus propios anuncios.
create policy "Advertisers can update their own ads."
  on public.ads for update using (auth.uid() = user_id);
-- Los anunciantes solo pueden eliminar sus propios anuncios.
create policy "Advertisers can delete their own ads."
  on public.ads for delete using (auth.uid() = user_id);

-- ** Políticas para la tabla RATINGS **
-- Todos pueden ver todas las calificaciones.
create policy "Ratings are viewable by everyone."
  on public.ratings for select using (true);
-- Los usuarios autenticados pueden crear calificaciones.
create policy "Users can create ratings."
  on public.ratings for insert with check (auth.uid() = user_id);
-- Los usuarios solo pueden actualizar/eliminar su propia calificación.
create policy "Users can update or delete their own ratings."
  on public.ratings for update using (auth.uid() = user_id);
create policy "Users can delete their own ratings."
  on public.ratings for delete using (auth.uid() = user_id);
-- Un anunciante no puede calificar su propio anuncio.
create policy "Advertisers cannot rate their own ads."
  on public.ratings for insert with check (
    auth.uid() != (select user_id from public.ads where id = ad_id)
  );

-- ** Políticas para la tabla COMMENTS **
-- Todos pueden ver los comentarios aprobados.
create policy "Everyone can view approved comments."
  on public.comments for select using (status = 'approved');
-- Los usuarios autenticados pueden ver sus propios comentarios pendientes.
create policy "Users can view their own pending comments."
  on public.comments for select using (auth.uid() = user_id);
-- El anunciante del anuncio puede ver todos los comentarios en su anuncio.
create policy "Advertisers can view all comments on their ads."
  on public.comments for select using (
    (select user_id from public.ads where id = ad_id) = auth.uid()
  );
-- Los usuarios autenticados pueden crear comentarios.
create policy "Authenticated users can create comments."
  on public.comments for insert with check (auth.uid() = user_id);
-- Los usuarios solo pueden eliminar sus propios comentarios.
create policy "Users can delete their own comments."
  on public.comments for delete using (auth.uid() = user_id);
-- El anunciante del anuncio puede actualizar el estado de los comentarios.
create policy "Advertisers can moderate comments on their ads."
  on public.comments for update using (
    (select user_id from public.ads where id = ad_id) = auth.uid()
  );


-- -----------------------------------------------------------------------------
-- 6. POLÍTICAS DE ALMACENAMIENTO (STORAGE)
-- -----------------------------------------------------------------------------

-- ** Políticas para el bucket AVATARS **
-- Cualquiera puede ver los avatares.
create policy "Avatar images are publicly accessible."
  on storage.objects for select using (bucket_id = 'avatars');
-- Un usuario solo puede subir/actualizar su propio avatar.
create policy "Users can upload their own avatar."
  on storage.objects for insert with check (bucket_id = 'avatars' and auth.uid() = (storage.foldername(name))[1]::uuid);
create policy "Users can update their own avatar."
  on storage.objects for update with check (bucket_id = 'avatars' and auth.uid() = (storage.foldername(name))[1]::uuid);

-- ** Políticas para los buckets AD_IMAGES y AD_VIDEOS **
-- Cualquiera puede ver las imágenes y videos de los anuncios.
create policy "Ad media is publicly accessible."
  on storage.objects for select using (bucket_id in ('ad_images', 'ad_videos'));
-- Los anunciantes solo pueden subir media a sus propios anuncios.
create policy "Advertisers can upload media for their ads."
  on storage.objects for insert with check (
    bucket_id in ('ad_images', 'ad_videos') and
    (select role from public.profiles where id = auth.uid()) = 'ADVERTISER'
    -- Se podría añadir una comprobación más estricta con una función que verifique si el 'folder' (ad_id) pertenece al usuario.
  );
create policy "Advertisers can update media for their ads."
  on storage.objects for update with check (
    bucket_id in ('ad_images', 'ad_videos') and
    (select role from public.profiles where id = auth.uid()) = 'ADVERTISER'
  );
create policy "Advertisers can delete media for their ads."
  on storage.objects for delete using (
    bucket_id in ('ad_images', 'ad_videos') and
    (select role from public.profiles where id = auth.uid()) = 'ADVERTISER'
  );
