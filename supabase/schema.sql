-- ------------------------------------------------------------------------------------------------
-- 1. TIPOS DE DATOS (ENUMS)
-- ------------------------------------------------------------------------------------------------
-- Define roles de usuario
drop type if exists public.user_role;
create type public.user_role as enum ('USER', 'ADVERTISER');

-- Define estados de anuncios
drop type if exists public.ad_status;
create type public.ad_status as enum ('active', 'inactive', 'draft', 'expired');

-- Define estados de comentarios
drop type if exists public.comment_status;
create type public.comment_status as enum ('pending', 'approved', 'rejected');

-- Define tipos de multimedia
drop type if exists public.media_type;
create type public.media_type as enum ('image', 'video');


-- ------------------------------------------------------------------------------------------------
-- 2. TABLAS
-- ------------------------------------------------------------------------------------------------
-- Tabla de perfiles de usuario
create table if not exists public.profiles (
  id uuid references auth.users on delete cascade not null primary key,
  updated_at timestamptz,
  username text unique,
  full_name text,
  avatar_url text,
  role user_role default 'USER',
  contact_email text,
  contact_whatsapp text,
  contact_telegram text,
  contact_social_url text,

  constraint username_length check (char_length(username) >= 3)
);

-- Tabla de categorías
create table if not exists public.categories (
  id int generated by default as identity primary key,
  name text not null
);

-- Tabla de ubicaciones (países, regiones, subregiones)
create table if not exists public.locations (
  id int generated by default as identity primary key,
  name text not null,
  type text not null, -- 'country', 'region', 'subregion'
  parent_id int references public.locations(id),
  code text -- Código ISO para países, código DANE para Colombia, etc.
);

-- Tabla de anuncios
create table if not exists public.ads (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles on delete cascade not null,
  title text not null,
  description text not null,
  category_id int references public.categories on delete set null,
  country_id int references public.locations on delete set null,
  region_id int references public.locations on delete set null,
  subregion_id int references public.locations on delete set null,
  status ad_status default 'draft' not null,
  created_at timestamptz default now(),
  updated_at timestamptz,
  boosted_until timestamptz,
  slug text unique not null
);

-- Tabla para contenido multimedia de anuncios (imágenes y videos)
create table if not exists public.ad_media (
    id bigint generated by default as identity primary key,
    ad_id bigint references public.ads on delete cascade not null,
    user_id uuid references public.profiles on delete cascade not null,
    url text not null,
    type media_type not null,
    is_cover boolean default false not null,
    created_at timestamptz default now()
);

-- Tabla de calificaciones
create table if not exists public.ratings (
  id bigint generated by default as identity primary key,
  ad_id bigint references public.ads on delete cascade not null,
  user_id uuid references public.profiles on delete cascade not null,
  score smallint not null constraint score_check check (score >= 1 and score <= 5),
  created_at timestamptz default now(),
  unique (ad_id, user_id)
);

-- Tabla de comentarios
create table if not exists public.comments (
  id bigint generated by default as identity primary key,
  ad_id bigint references public.ads on delete cascade not null,
  user_id uuid references public.profiles on delete cascade not null,
  content text not null,
  status comment_status default 'pending' not null,
  created_at timestamptz default now()
);

-- Tabla de transacciones de potenciación
create table if not exists public.boost_transactions (
    id bigint generated by default as identity primary key,
    ad_id bigint references public.ads on delete cascade not null,
    user_id uuid references public.profiles on delete cascade not null,
    boost_duration_days int not null,
    transaction_date timestamptz default now(),
    payment_id text -- Para futura integración con Stripe, etc.
);


-- ------------------------------------------------------------------------------------------------
-- 3. FUNCIÓN Y TRIGGER PARA CREAR PERFILES
-- ------------------------------------------------------------------------------------------------
-- Función para insertar una fila en public.profiles cuando un nuevo usuario se registra
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public.profiles (id, full_name, username, role)
  values (
    new.id,
    new.raw_user_meta_data->>'full_name',
    new.raw_user_meta_data->>'username',
    (new.raw_user_meta_data->>'role')::user_role
  );
  return new;
end;
$$;

-- Trigger que ejecuta la función cada vez que se crea un usuario
drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();


-- ------------------------------------------------------------------------------------------------
-- 4. ALMACENAMIENTO (STORAGE)
-- ------------------------------------------------------------------------------------------------
-- Bucket para avatares
insert into storage.buckets (id, name, public)
values ('avatars', 'avatars', true)
on conflict (id) do nothing;

-- Bucket para imágenes y videos de anuncios
insert into storage.buckets (id, name, public)
values ('ad_media', 'ad_media', true)
on conflict (id) do nothing;


-- ------------------------------------------------------------------------------------------------
-- 5. POLÍTICAS DE SEGURIDAD A NIVEL DE FILA (RLS)
-- ------------------------------------------------------------------------------------------------

-- Habilitar RLS en todas las tablas
alter table public.profiles enable row level security;
alter table public.ads enable row level security;
alter table public.ad_media enable row level security;
alter table public.categories enable row level security;
alter table public.locations enable row level security;
alter table public.ratings enable row level security;
alter table public.comments enable row level security;
alter table public.boost_transactions enable row level security;


--- Políticas para la tabla PROFILES ---
drop policy if exists "Public profiles are viewable by everyone." on public.profiles;
create policy "Public profiles are viewable by everyone." on public.profiles
  for select using (true);

drop policy if exists "Users can insert their own profile." on public.profiles;
create policy "Users can insert their own profile." on public.profiles
  for insert with check (auth.uid() = id);

drop policy if exists "Users can update their own profile." on public.profiles;
create policy "Users can update their own profile." on public.profiles
  for update using (auth.uid() = id) with check (auth.uid() = id);


--- Políticas para la tabla ADS ---
drop policy if exists "Active ads are viewable by everyone." on public.ads;
create policy "Active ads are viewable by everyone." on public.ads
  for select using (status = 'active');

drop policy if exists "Advertisers can view their own ads." on public.ads;
create policy "Advertisers can view their own ads." on public.ads
  for select using (auth.uid() = user_id);

drop policy if exists "Advertisers can insert their own ads." on public.ads;
create policy "Advertisers can insert their own ads." on public.ads
  for insert with check (auth.uid() = user_id and (select role from profiles where id = auth.uid()) = 'ADVERTISER');

drop policy if exists "Advertisers can update their own ads." on public.ads;
create policy "Advertisers can update their own ads." on public.ads
  for update using (auth.uid() = user_id) with check (auth.uid() = user_id);

drop policy if exists "Advertisers can delete their own ads." on public.ads;
create policy "Advertisers can delete their own ads." on public.ads
  for delete using (auth.uid() = user_id);


--- Políticas para la tabla AD_MEDIA ---
drop policy if exists "Media is public." on public.ad_media;
create policy "Media is public." on public.ad_media
    for select using (true);

drop policy if exists "Advertisers can insert their own media." on public.ad_media;
create policy "Advertisers can insert their own media." on public.ad_media
    for insert with check (auth.uid() = user_id);

drop policy if exists "Advertisers can update their own media." on public.ad_media;
create policy "Advertisers can update their own media." on public.ad_media
    for update using (auth.uid() = user_id) with check (auth.uid() = user_id);

drop policy if exists "Advertisers can delete their own media." on public.ad_media;
create policy "Advertisers can delete their own media." on public.ad_media
    for delete using (auth.uid() = user_id);


--- Políticas para tablas CATEGORIES y LOCATIONS ---
drop policy if exists "Categories are public." on public.categories;
create policy "Categories are public." on public.categories
    for select using (true);

drop policy if exists "Locations are public." on public.locations;
create policy "Locations are public." on public.locations
    for select using (true);


--- Políticas para la tabla RATINGS ---
drop policy if exists "Ratings are public." on public.ratings;
create policy "Ratings are public." on public.ratings
    for select using (true);
    
drop policy if exists "Users can manage their own ratings." on public.ratings;
create policy "Users can manage their own ratings." on public.ratings
    for all using (auth.uid() = user_id) with check (
        auth.uid() = user_id and
        -- El usuario no puede calificar su propio anuncio
        (select user_id from ads where id = ad_id) <> auth.uid()
    );

--- Políticas para la tabla COMMENTS ---
drop policy if exists "Approved comments are public." on public.comments;
create policy "Approved comments are public." on public.comments
    for select using (status = 'approved');

drop policy if exists "Users can see their own pending/rejected comments." on public.comments;
create policy "Users can see their own pending/rejected comments." on public.comments
    for select using (auth.uid() = user_id);
    
drop policy if exists "Ad owners can see all comments on their ads." on public.comments;
create policy "Ad owners can see all comments on their ads." on public.comments
    for select using ((select user_id from ads where id = ad_id) = auth.uid());

drop policy if exists "Users can create comments." on public.comments;
create policy "Users can create comments." on public.comments
    for insert with check (
        auth.uid() = user_id and
        (select user_id from ads where id = ad_id) <> auth.uid()
    );

drop policy if exists "Ad owners can update (moderate) comments on their ads." on public.comments;
create policy "Ad owners can update (moderate) comments on their ads." on public.comments
    for update using ((select user_id from ads where id = ad_id) = auth.uid()) with check (false); -- Ad owner cannot change comment content, only status

drop policy if exists "Users can delete their own comments." on public.comments;
create policy "Users can delete their own comments." on public.comments
  for delete using (user_id = auth.uid());


--- Políticas para la tabla BOOST_TRANSACTIONS ---
drop policy if exists "Users can view their own boost transactions." on public.boost_transactions;
create policy "Users can view their own boost transactions." on public.boost_transactions
    for select using (auth.uid() = user_id);

drop policy if exists "Advertisers can create boost transactions for their own ads." on public.boost_transactions;
create policy "Advertisers can create boost transactions for their own ads." on public.boost_transactions
    for insert with check (
        auth.uid() = user_id and
        (select user_id from ads where id = ad_id) = auth.uid()
    );


-- ------------------------------------------------------------------------------------------------
-- 6. POLÍTICAS DE ALMACENAMIENTO (STORAGE)
-- ------------------------------------------------------------------------------------------------

-- Políticas para el bucket AVATARS
drop policy if exists "Avatar images are publicly accessible." on storage.objects;
create policy "Avatar images are publicly accessible." on storage.objects
  for select using (bucket_id = 'avatars');

drop policy if exists "Anyone can upload an avatar." on storage.objects;
create policy "Anyone can upload an avatar." on storage.objects
  for insert with check (bucket_id = 'avatars');

drop policy if exists "Users can update their own avatar." on storage.objects;
create policy "Users can update their own avatar." on storage.objects
    for update using (auth.uid() = owner) with check (bucket_id = 'avatars');

-- Políticas para el bucket AD_MEDIA
drop policy if exists "Ad media is publicly accessible." on storage.objects;
create policy "Ad media is publicly accessible." on storage.objects
    for select using (bucket_id = 'ad_media');

drop policy if exists "Advertisers can upload media for their ads." on storage.objects;
create policy "Advertisers can upload media for their ads." on storage.objects
    for insert with check (
        bucket_id = 'ad_media' and
        auth.uid() = (
            select user_id from public.ads where id = (string_to_array(name, '/'))[2]::bigint
        )
    );

drop policy if exists "Advertisers can update media for their ads." on storage.objects;
create policy "Advertisers can update media for their ads." on storage.objects
    for update using (
        bucket_id = 'ad_media' and
        auth.uid() = (
            select user_id from public.ads where id = (string_to_array(name, '/'))[2]::bigint
        )
    ) with check (bucket_id = 'ad_media');

drop policy if exists "Advertisers can delete media for their ads." on storage.objects;
create policy "Advertisers can delete media for their ads." on storage.objects
    for delete using (
        bucket_id = 'ad_media' and
        auth.uid() = (
            select user_id from public.ads where id = (string_to_array(name, '/'))[2]::bigint
        )
    );
