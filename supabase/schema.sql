-- =================================================================
-- HABILITAR UUID EXTENSION
-- =================================================================
create extension if not exists "uuid-ossp" with schema extensions;

-- =================================================================
-- TIPOS ENUM PERSONALIZADOS
-- =================================================================
drop type if exists public.user_role;
create type public.user_role as enum ('USER', 'ADVERTISER');

drop type if exists public.ad_status;
create type public.ad_status as enum ('active', 'inactive', 'draft', 'expired');

drop type if exists public.media_type;
create type public.media_type as enum ('image', 'video');

drop type if exists public.location_type;
create type public.location_type as enum ('country', 'region', 'subregion');

drop type if exists public.comment_status;
create type public.comment_status as enum ('pending', 'approved', 'rejected');

-- =================================================================
-- TABLAS Y SUS POLÍTICAS DE SEGURIDAD (RLS)
-- =================================================================

-- -----------------------------------------------------------------
-- TABLA: locations
-- Almacena países, regiones y subregiones.
-- -----------------------------------------------------------------
drop policy if exists "Public can read all locations" on public.locations;
drop table if exists public.locations;

create table public.locations (
  id bigint generated by default as identity primary key,
  name text not null,
  type public.location_type not null,
  parent_id bigint references public.locations(id) on delete cascade,
  code text,
  phone_code text,
  slug text unique
);
comment on table public.locations is 'Stores countries, regions, and subregions.';

-- Políticas para locations
alter table public.locations enable row level security;

create policy "Public can read all locations" on public.locations
  for select using (true);


-- -----------------------------------------------------------------
-- TABLA: categories
-- Almacena las categorías de los anuncios.
-- -----------------------------------------------------------------
drop policy if exists "Public can read all categories" on public.categories;
drop table if exists public.categories;

create table public.categories (
  id bigint generated by default as identity primary key,
  name text not null
);
comment on table public.categories is 'Stores ad categories.';

-- Políticas para categories
alter table public.categories enable row level security;

create policy "Public can read all categories" on public.categories
  for select using (true);

-- -----------------------------------------------------------------
-- TABLA: profiles
-- Almacena datos públicos de los usuarios.
-- -----------------------------------------------------------------
drop policy if exists "Users can update their own profile" on public.profiles;
drop policy if exists "Users can insert their own profile" on public.profiles;
drop policy if exists "Public can read all profiles" on public.profiles;
drop table if exists public.profiles;

create table public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  username text unique not null,
  full_name text,
  avatar_url text,
  role public.user_role not null default 'USER',
  updated_at timestamptz,
  country_id bigint references public.locations(id),
  contact_email text,
  contact_whatsapp text,
  contact_telegram text,
  contact_social_url text,
  constraint username_length check (char_length(username) >= 3)
);
comment on table public.profiles is 'Stores public profile data for each user.';

-- Políticas para profiles
alter table public.profiles enable row level security;

create policy "Public can read all profiles" on public.profiles
  for select using (true);

create policy "Users can insert their own profile" on public.profiles
  for insert with check (auth.uid() = id);

create policy "Users can update their own profile" on public.profiles
  for update using (auth.uid() = id) with check (auth.uid() = id);


-- -----------------------------------------------------------------
-- TABLA: ads
-- Almacena los anuncios creados por los anunciantes.
-- -----------------------------------------------------------------
drop policy if exists "Advertisers can delete their own ads" on public.ads;
drop policy if exists "Advertisers can update their own ads" on public.ads;
drop policy if exists "Advertisers can insert new ads" on public.ads;
drop policy if exists "Advertisers can read their own ads" on public.ads;
drop policy if exists "Public can read active ads" on public.ads;
drop table if exists public.ads;

create table public.ads (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  title text not null,
  description text not null,
  category_id bigint not null references public.categories(id),
  country_id bigint references public.locations(id),
  region_id bigint references public.locations(id),
  subregion_id bigint references public.locations(id),
  status public.ad_status not null default 'draft',
  created_at timestamptz not null default now(),
  updated_at timestamptz,
  boosted_until timestamptz,
  slug text not null unique,
  tags text[]
);
comment on table public.ads is 'Stores classified ads created by advertisers.';
create index if not exists ads_user_id_idx on public.ads (user_id);
create index if not exists ads_status_idx on public.ads (status);

-- Políticas para ads
alter table public.ads enable row level security;

create policy "Public can read active ads" on public.ads
  for select using (status = 'active');

create policy "Advertisers can read their own ads" on public.ads
  for select using (auth.uid() = user_id);

create policy "Advertisers can insert new ads" on public.ads
  for insert with check (
    auth.uid() = user_id and
    (select role from public.profiles where id = auth.uid()) = 'ADVERTISER'
  );

create policy "Advertisers can update their own ads" on public.ads
  for update using (
    auth.uid() = user_id and
    (select role from public.profiles where id = auth.uid()) = 'ADVERTISER'
  ) with check (auth.uid() = user_id);

create policy "Advertisers can delete their own ads" on public.ads
  for delete using (auth.uid() = user_id);


-- -----------------------------------------------------------------
-- TABLA: ad_media
-- Almacena imágenes y videos asociados a un anuncio.
-- -----------------------------------------------------------------
drop policy if exists "Users can delete their own media" on public.ad_media;
drop policy if exists "Users can update their own media" on public.ad_media;
drop policy if exists "Advertisers can insert media for their ads" on public.ad_media;
drop policy if exists "Public can read all media" on public.ad_media;
drop table if exists public.ad_media;

create table public.ad_media (
  id bigint generated by default as identity primary key,
  ad_id bigint not null references public.ads(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  url text not null,
  type public.media_type not null,
  is_cover boolean not null default false,
  created_at timestamptz not null default now()
);
comment on table public.ad_media is 'Stores images and videos for ads.';
create index if not exists ad_media_ad_id_idx on public.ad_media (ad_id);

-- Políticas para ad_media
alter table public.ad_media enable row level security;

create policy "Public can read all media" on public.ad_media
  for select using (true);

create policy "Advertisers can insert media for their ads" on public.ad_media
  for insert with check (auth.uid() = user_id);

create policy "Users can update their own media" on public.ad_media
  for update using (auth.uid() = user_id);

create policy "Users can delete their own media" on public.ad_media
  for delete using (auth.uid() = user_id);


-- -----------------------------------------------------------------
-- TABLA: ad_ratings
-- Almacena las calificaciones de los anuncios.
-- -----------------------------------------------------------------
drop policy if exists "Users can delete their own ratings" on public.ad_ratings;
drop policy if exists "Users can update their own ratings" on public.ad_ratings;
drop policy if exists "Authenticated users can insert ratings" on public.ad_ratings;
drop policy if exists "Public can read all ratings" on public.ad_ratings;
drop table if exists public.ad_ratings;

create table public.ad_ratings (
  id bigint generated by default as identity primary key,
  ad_id bigint not null references public.ads(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  rating smallint not null check (rating >= 1 and rating <= 5),
  created_at timestamptz not null default now(),
  unique (ad_id, user_id)
);
comment on table public.ad_ratings is 'Stores user ratings for ads.';

-- Políticas para ad_ratings
alter table public.ad_ratings enable row level security;

create policy "Public can read all ratings" on public.ad_ratings
  for select using (true);

create policy "Authenticated users can insert ratings" on public.ad_ratings
  for insert with check (
    auth.uid() = user_id and
    -- Prevent user from rating their own ad
    (select user_id from public.ads where id = ad_id) <> auth.uid()
  );

create policy "Users can update their own ratings" on public.ad_ratings
  for update using (auth.uid() = user_id);

create policy "Users can delete their own ratings" on public.ad_ratings
  for delete using (auth.uid() = user_id);

-- -----------------------------------------------------------------
-- TABLA: ad_comments
-- Almacena los comentarios de los anuncios.
-- -----------------------------------------------------------------
drop policy if exists "Users can delete their own comments" on public.ad_comments;
drop policy if exists "Advertisers can update comment status on their ads" on public.ad_comments;
drop policy if exists "Authenticated users can insert comments" on public.ad_comments;
drop policy if exists "Advertisers can see all comments on their ads" on public.ad_comments;
drop policy if exists "Public can read approved comments" on public.ad_comments;
drop table if exists public.ad_comments;

create table public.ad_comments (
  id bigint generated by default as identity primary key,
  ad_id bigint not null references public.ads(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  parent_comment_id bigint references public.ad_comments(id) on delete cascade,
  comment text not null,
  status public.comment_status not null default 'pending',
  created_at timestamptz not null default now()
);
comment on table public.ad_comments is 'Stores user comments for ads.';

-- Políticas para ad_comments
alter table public.ad_comments enable row level security;

create policy "Public can read approved comments" on public.ad_comments
  for select using (status = 'approved');

create policy "Advertisers can see all comments on their ads" on public.ad_comments
  for select using (
    (select user_id from public.ads where id = ad_id) = auth.uid()
  );

create policy "Authenticated users can insert comments" on public.ad_comments
  for insert with check (
    auth.uid() = user_id and
    -- Prevent user from commenting on their own ad
    (select user_id from public.ads where id = ad_id) <> auth.uid()
  );

create policy "Advertisers can update comment status on their ads" on public.ad_comments
  for update using (
    (select user_id from public.ads where id = ad_id) = auth.uid()
  ) with check ( (select user_id from public.ads where id = ad_id) = auth.uid() );


create policy "Users can delete their own comments" on public.ad_comments
  for delete using (auth.uid() = user_id);


-- =================================================================
-- FUNCIONES Y TRIGGERS
-- =================================================================

-- -----------------------------------------------------------------
-- FUNCIÓN: handle_new_user
-- Crea un perfil de usuario cuando se registra un nuevo usuario.
-- -----------------------------------------------------------------
drop trigger if exists on_auth_user_created on auth.users;
drop function if exists public.handle_new_user();

create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public.profiles (id, full_name, username, role)
  values (
    new.id,
    new.raw_user_meta_data->>'full_name',
    new.raw_user_meta_data->>'username',
    (new.raw_user_meta_data->>'role')::public.user_role
  );
  return new;
end;
$$;

-- Trigger para ejecutar la función
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();


-- =================================================================
-- ALMACENAMIENTO (STORAGE) Y POLÍTICAS
-- =================================================================

-- -----------------------------------------------------------------
-- BUCKET: avatars
-- Para las fotos de perfil de los usuarios.
-- -----------------------------------------------------------------
drop policy if exists "Users can update their own avatar" on storage.objects;
drop policy if exists "Users can upload an avatar" on storage.objects;
drop policy if exists "Anyone can view avatars" on storage.objects;
drop policy if exists "Give users access to their own folder" on storage.objects;

insert into storage.buckets (id, name, public)
values ('avatars', 'avatars', true)
on conflict (id) do nothing;

create policy "Anyone can view avatars" on storage.objects
  for select to public
  using ( bucket_id = 'avatars' );

create policy "Users can upload an avatar" on storage.objects
  for insert to authenticated
  with check ( bucket_id = 'avatars' and auth.uid() = (storage.foldername(name))[1]::uuid );

create policy "Users can update their own avatar" on storage.objects
  for update to authenticated
  using ( bucket_id = 'avatars' and auth.uid() = (storage.foldername(name))[1]::uuid );


-- -----------------------------------------------------------------
-- BUCKET: ad_media
-- Para imágenes y videos de los anuncios.
-- -----------------------------------------------------------------
drop policy if exists "Users can delete their own media" on storage.objects;
drop policy if exists "Users can update their own media" on storage.objects;
drop policy if exists "Advertisers can upload media" on storage.objects;
drop policy if exists "Anyone can view ad media" on storage.objects;

insert into storage.buckets (id, name, public)
values ('ad_media', 'ad_media', true)
on conflict (id) do nothing;

create policy "Anyone can view ad media" on storage.objects
  for select to public
  using ( bucket_id = 'ad_media' );

create policy "Advertisers can upload media" on storage.objects
  for insert to authenticated
  with check ( bucket_id = 'ad_media' and auth.uid() = (storage.foldername(name))[1]::uuid );
  
create policy "Users can update their own media" on storage.objects
  for update to authenticated
  using ( bucket_id = 'ad_media' and auth.uid() = (storage.foldername(name))[1]::uuid );

create policy "Users can delete their own media" on storage.objects
  for delete to authenticated
  using ( bucket_id = 'ad_media' and auth.uid() = (storage.foldername(name))[1]::uuid );


-- =================================================================
-- DATOS INICIALES (DUMMY DATA)
-- =================================================================

-- -----------------------------------------------------------------
-- DATOS: categories
-- -----------------------------------------------------------------
insert into public.categories (name) values
  ('Scorts'),
  ('Chicas Trans'),
  ('Scorts Gay'),
  ('Servicios Virtuales'),
  ('Masajes')
on conflict do nothing;

-- -----------------------------------------------------------------
-- DATOS: locations
-- -----------------------------------------------------------------
-- Países
insert into public.locations (id, name, type, phone_code, slug) values
(1, 'Colombia', 'country', '57', 'colombia')
on conflict (id) do update set name = excluded.name, type = excluded.type, phone_code = excluded.phone_code, slug = excluded.slug;

-- Departamentos de Colombia
insert into public.locations (id, name, type, parent_id, slug) values
(101, 'Antioquia', 'region', 1, 'antioquia'),
(102, 'Cundinamarca', 'region', 1, 'cundinamarca'),
(103, 'Valle del Cauca', 'region', 1, 'valle-del-cauca')
on conflict (id) do update set name = excluded.name, type = excluded.type, parent_id = excluded.parent_id, slug = excluded.slug;

-- Ciudades
insert into public.locations (id, name, type, parent_id, slug) values
(10101, 'Medellín', 'subregion', 101, 'medellin'),
(10201, 'Bogotá', 'subregion', 102, 'bogota'),
(10301, 'Cali', 'subregion', 103, 'cali')
on conflict (id) do update set name = excluded.name, type = excluded.type, parent_id = excluded.parent_id, slug = excluded.slug;
