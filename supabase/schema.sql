
-- ### SETUP: TIPOS Y FUNCIONES ###

-- 1. Crear ENUM para roles de usuario
DROP TYPE IF EXISTS public.user_role;
CREATE TYPE public.user_role AS ENUM ('USER', 'ADVERTISER');

-- 2. Crear ENUM para estados de anuncios
DROP TYPE IF EXISTS public.ad_status;
CREATE TYPE public.ad_status AS ENUM ('active', 'inactive', 'draft', 'expired');

-- 3. Crear ENUM para estados de comentarios
DROP TYPE IF EXISTS public.comment_status;
CREATE TYPE public.comment_status AS ENUM ('pending', 'approved', 'rejected');

-- 4. Función para crear perfil de usuario automáticamente
DROP FUNCTION IF EXISTS public.handle_new_user();
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  INSERT INTO public.profiles (id, full_name, username, role)
  VALUES (
    new.id,
    new.raw_user_meta_data->>'full_name',
    new.raw_user_meta_data->>'username',
    (new.raw_user_meta_data->>'role')::user_role
  );
  RETURN new;
END;
$$;


-- ### SETUP: TABLAS ###

-- 1. Tabla de Ubicaciones (Países, Regiones, etc.)
DROP TABLE IF EXISTS public.locations CASCADE;
CREATE TABLE public.locations (
  id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  name text NOT NULL,
  type text NOT NULL, -- 'country', 'region', 'subregion'
  parent_id integer NULL REFERENCES public.locations(id),
  code text NULL, -- ej. 'ES', 'US'
  phone_code text NULL
);
COMMENT ON TABLE public.locations IS 'Almacena datos jerárquicos de ubicaciones.';

-- 2. Tabla de Categorías
DROP TABLE IF EXISTS public.categories CASCADE;
CREATE TABLE public.categories (
  id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  name text NOT NULL UNIQUE
);
COMMENT ON TABLE public.categories IS 'Almacena las categorías de los anuncios.';

-- 3. Tabla de Perfiles de Usuario
DROP TABLE IF EXISTS public.profiles CASCADE;
CREATE TABLE public.profiles (
  id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  updated_at timestamptz,
  username text UNIQUE,
  full_name text,
  avatar_url text,
  role user_role NOT NULL DEFAULT 'USER',
  
  -- Campos de contacto específicos para anunciantes
  country_id integer NULL REFERENCES public.locations(id) ON DELETE SET NULL,
  contact_email text,
  contact_whatsapp text,
  contact_telegram text,
  contact_social_url text,

  CONSTRAINT username_length CHECK (char_length(username) >= 3)
);
COMMENT ON TABLE public.profiles IS 'Almacena datos públicos y de contacto de los perfiles de usuario.';

-- 4. Tabla de Anuncios
DROP TABLE IF EXISTS public.ads CASCADE;
CREATE TABLE public.ads (
  id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  title text NOT NULL,
  description text NOT NULL,
  category_id integer NOT NULL REFERENCES public.categories(id),
  country_id integer NULL REFERENCES public.locations(id),
  region_id integer NULL REFERENCES public.locations(id),
  subregion_id integer NULL REFERENCES public.locations(id),
  tags text[] NULL,
  status ad_status NOT NULL DEFAULT 'draft',
  slug text NOT NULL UNIQUE,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz,
  boosted_until timestamptz
);
COMMENT ON TABLE public.ads IS 'Contiene todos los anuncios publicados por los usuarios.';

-- 5. Tabla de Media de Anuncios (Imágenes y Videos)
DROP TABLE IF EXISTS public.ad_media;
CREATE TABLE public.ad_media (
  id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  ad_id bigint NOT NULL REFERENCES public.ads(id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  url text NOT NULL,
  type text NOT NULL, -- 'image' or 'video'
  is_cover boolean NOT NULL DEFAULT false,
  created_at timestamptz NOT NULL DEFAULT now()
);
COMMENT ON TABLE public.ad_media IS 'Almacena imágenes y videos asociados a los anuncios.';

-- 6. Tabla de Calificaciones de Anuncios
DROP TABLE IF EXISTS public.ad_ratings;
CREATE TABLE public.ad_ratings (
  id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  ad_id bigint NOT NULL REFERENCES public.ads(id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  rating smallint NOT NULL CHECK (rating >= 1 AND rating <= 5),
  created_at timestamptz NOT NULL DEFAULT now(),
  UNIQUE(ad_id, user_id)
);
COMMENT ON TABLE public.ad_ratings IS 'Calificaciones de 1 a 5 estrellas para los anuncios.';

-- 7. Tabla de Comentarios de Anuncios
DROP TABLE IF EXISTS public.ad_comments;
CREATE TABLE public.ad_comments (
  id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  ad_id bigint NOT NULL REFERENCES public.ads(id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  comment text NOT NULL,
  status comment_status NOT NULL DEFAULT 'pending',
  created_at timestamptz NOT NULL DEFAULT now()
);
COMMENT ON TABLE public.ad_comments IS 'Comentarios en los anuncios, con estado de moderación.';


-- ### SETUP: TRIGGERS ###

-- 1. Trigger para crear perfil al registrar nuevo usuario
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- 2. Trigger para manejar `updated_at` en la tabla `ads`
CREATE OR REPLACE FUNCTION public.set_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS handle_updated_at ON public.ads;
CREATE TRIGGER handle_updated_at
  BEFORE UPDATE ON public.ads
  FOR EACH ROW
  EXECUTE PROCEDURE public.set_updated_at();


-- ### SETUP: ALMACENAMIENTO (STORAGE) ###

-- 1. Bucket para avatares de perfil
INSERT INTO storage.buckets (id, name, public)
VALUES ('avatars', 'avatars', true)
ON CONFLICT (id) DO NOTHING;

-- 2. Bucket para imágenes y videos de anuncios
INSERT INTO storage.buckets (id, name, public)
VALUES ('ad_media', 'ad_media', true)
ON CONFLICT (id) DO NOTHING;


-- ### SETUP: SEGURIDAD A NIVEL DE FILA (RLS) ###

-- Habilitar RLS en todas las tablas
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.locations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ads ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ad_media ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ad_ratings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ad_comments ENABLE ROW LEVEL SECURITY;

-- Políticas para `profiles`
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone."
ON public.profiles FOR SELECT
USING (true);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile."
ON public.profiles FOR INSERT
WITH CHECK ((auth.uid() = id));

DROP POLICY IF EXISTS "Users can update their own profile." ON public.profiles;
CREATE POLICY "Users can update their own profile."
ON public.profiles FOR UPDATE
USING ((auth.uid() = id));


-- Políticas para `locations` y `categories` (solo lectura para todos)
DROP POLICY IF EXISTS "Locations are viewable by everyone." ON public.locations;
CREATE POLICY "Locations are viewable by everyone."
ON public.locations FOR SELECT
USING (true);

DROP POLICY IF EXISTS "Categories are viewable by everyone." ON public.categories;
CREATE POLICY "Categories are viewable by everyone."
ON public.categories FOR SELECT
USING (true);


-- Políticas para `ads`
DROP POLICY IF EXISTS "Ads are viewable by everyone." ON public.ads;
CREATE POLICY "Ads are viewable by everyone."
ON public.ads FOR SELECT
USING (true);

DROP POLICY IF EXISTS "Advertisers can create their own ads." ON public.ads;
CREATE POLICY "Advertisers can create their own ads."
ON public.ads FOR INSERT
TO authenticated
WITH CHECK (
  (auth.uid() = user_id) AND
  ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'ADVERTISER')
);

DROP POLICY IF EXISTS "Advertisers can update their own ads." ON public.ads;
CREATE POLICY "Advertisers can update their own ads."
ON public.ads FOR UPDATE
TO authenticated
USING ((auth.uid() = user_id));

DROP POLICY IF EXISTS "Advertisers can delete their own ads." ON public.ads;
CREATE POLICY "Advertisers can delete their own ads."
ON public.ads FOR DELETE
TO authenticated
USING ((auth.uid() = user_id));


-- Políticas para `ad_media`
DROP POLICY IF EXISTS "Ad media is viewable by everyone." ON public.ad_media;
CREATE POLICY "Ad media is viewable by everyone."
ON public.ad_media FOR SELECT
USING (true);

DROP POLICY IF EXISTS "Advertisers can manage media for their own ads." ON public.ad_media;
CREATE POLICY "Advertisers can manage media for their own ads."
ON public.ad_media FOR ALL
TO authenticated
USING ((auth.uid() = user_id))
WITH CHECK ((auth.uid() = user_id));


-- Políticas para `ad_ratings`
DROP POLICY IF EXISTS "Ratings are viewable by everyone." ON public.ad_ratings;
CREATE POLICY "Ratings are viewable by everyone."
ON public.ad_ratings FOR SELECT
USING (true);

DROP POLICY IF EXISTS "Authenticated users can rate ads." ON public.ad_ratings;
CREATE POLICY "Authenticated users can rate ads."
ON public.ad_ratings FOR INSERT
TO authenticated
WITH CHECK (
  (auth.uid() = user_id) AND
  -- El usuario no puede calificar su propio anuncio
  (user_id <> (SELECT user_id FROM public.ads WHERE id = ad_id))
);

DROP POLICY IF EXISTS "Users can update their own rating." ON public.ad_ratings;
CREATE POLICY "Users can update their own rating."
ON public.ad_ratings FOR UPDATE
TO authenticated
USING ((auth.uid() = user_id));


-- Políticas para `ad_comments`
DROP POLICY IF EXISTS "Public can see approved comments." ON public.ad_comments;
CREATE POLICY "Public can see approved comments."
ON public.ad_comments FOR SELECT
USING (status = 'approved');

DROP POLICY IF EXISTS "Authenticated users can create comments." ON public.ad_comments;
CREATE POLICY "Authenticated users can create comments."
ON public.ad_comments FOR INSERT
TO authenticated
WITH CHECK ((auth.uid() = user_id));

DROP POLICY IF EXISTS "Users can delete their own comments." ON public.ad_comments;
CREATE POLICY "Users can delete their own comments."
ON public.ad_comments FOR DELETE
TO authenticated
USING ((auth.uid() = user_id));

DROP POLICY IF EXISTS "Advertisers can see all comments on their ads." ON public.ad_comments;
CREATE POLICY "Advertisers can see all comments on their ads."
ON public.ad_comments FOR SELECT
TO authenticated
USING (
  -- El anunciante es dueño del anuncio comentado
  (auth.uid() = (SELECT user_id FROM public.ads WHERE id = ad_id))
);

DROP POLICY IF EXISTS "Advertisers can moderate comments on their ads." ON public.ad_comments;
CREATE POLICY "Advertisers can moderate comments on their ads."
ON public.ad_comments FOR UPDATE
TO authenticated
USING (
  (auth.uid() = (SELECT user_id FROM public.ads WHERE id = ad_id))
)
-- Solo pueden cambiar el estado, no el texto del comentario
WITH CHECK ((auth.uid() = (SELECT user_id FROM public.ads WHERE id = ad_id)));


-- Políticas para `storage.objects` (avatares y media)
DROP POLICY IF EXISTS "Avatar images are publicly accessible." ON storage.objects;
CREATE POLICY "Avatar images are publicly accessible."
ON storage.objects FOR SELECT
USING (bucket_id = 'avatars');

DROP POLICY IF EXISTS "Anyone can upload an avatar." ON storage.objects;
CREATE POLICY "Anyone can upload an avatar."
ON storage.objects FOR INSERT
WITH CHECK (bucket_id = 'avatars');

DROP POLICY IF EXISTS "Ad media is publicly accessible." ON storage.objects;
CREATE POLICY "Ad media is publicly accessible."
ON storage.objects FOR SELECT
USING (bucket_id = 'ad_media');

DROP POLICY IF EXISTS "Advertisers can upload media for their ads." ON storage.objects;
CREATE POLICY "Advertisers can upload media for their ads."
ON storage.objects FOR INSERT
TO authenticated
WITH CHECK (
  (bucket_id = 'ad_media') AND
  ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'ADVERTISER')
);

DROP POLICY IF EXISTS "Advertisers can delete their own ad media." ON storage.objects;
CREATE POLICY "Advertisers can delete their own ad media."
ON storage.objects FOR DELETE
TO authenticated
USING (
  (bucket_id = 'ad_media') AND
  -- El path del objeto contiene el user_id del usuario autenticado
  (auth.uid()::text = (storage.foldername(name))[1])
);
